<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Tag Championship</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Roboto:wght@400;700&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1a202c;
            overflow: hidden;
            touch-action: none;
        }

        .marker-font {
            font-family: 'Permanent Marker', cursive;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; 
        }

        .player-card {
            transition: all 0.3s ease;
        }
        .player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        
        .control-key {
            box-shadow: 0 4px 0 #2d3748;
            transition: all 0.1s;
        }
        .control-key:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #2d3748;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center text-white relative">

    <!-- Background Pattern -->
    <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: radial-gradient(#4a5568 1px, transparent 1px); background-size: 20px 20px;"></div>

    <!-- Main Menu -->
    <div id="mainMenu" class="z-10 flex flex-col items-center gap-8 w-full max-w-4xl p-6">
        <h1 class="text-6xl md:text-8xl marker-font text-yellow-400 drop-shadow-lg tracking-wider text-center transform -rotate-2">
            STICKMAN<br><span class="text-red-500">TAG</span>
        </h1>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 w-full">
            <!-- Player Count Selection -->
            <div class="bg-gray-800 p-6 rounded-xl border-2 border-gray-700 shadow-xl">
                <h2 class="text-2xl font-bold mb-4 text-blue-400">Players</h2>
                <div class="flex justify-between gap-2">
                    <button onclick="setPlayerCount(2)" id="btn-p2" class="flex-1 py-3 rounded-lg bg-blue-600 hover:bg-blue-500 font-bold transition shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">2 Players</button>
                    <button onclick="setPlayerCount(3)" id="btn-p3" class="flex-1 py-3 rounded-lg bg-gray-700 hover:bg-gray-600 font-bold transition shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">3 Players</button>
                    <button onclick="setPlayerCount(4)" id="btn-p4" class="flex-1 py-3 rounded-lg bg-gray-700 hover:bg-gray-600 font-bold transition shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">4 Players</button>
                </div>
            </div>

            <!-- Game Mode Selection -->
            <div class="bg-gray-800 p-6 rounded-xl border-2 border-gray-700 shadow-xl">
                <h2 class="text-2xl font-bold mb-4 text-green-400">Game Mode</h2>
                <div class="flex gap-2">
                    <button onclick="setGameMode('classic')" id="btn-mode-classic" class="flex-1 py-3 rounded-lg bg-green-600 hover:bg-green-500 font-bold transition shadow-lg border-b-4 border-green-800 active:border-b-0 active:translate-y-1">Classic Tag</button>
                    <button onclick="setGameMode('infection')" id="btn-mode-infection" class="flex-1 py-3 rounded-lg bg-gray-700 hover:bg-gray-600 font-bold transition shadow-lg border-b-4 border-gray-900 active:border-b-0 active:translate-y-1">Infection</button>
                </div>
            </div>
        </div>

        <!-- Character Customization -->
        <div class="w-full bg-gray-800 p-6 rounded-xl border-2 border-gray-700 shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-purple-400">Customize Fighters</h2>
                <span class="text-sm text-gray-400">Change colors & styles below</span>
            </div>
            
            <div id="customizationGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <!-- Generated via JS -->
            </div>
        </div>

        <button onclick="startGame()" class="mt-4 px-12 py-4 bg-red-600 hover:bg-red-500 text-3xl font-black rounded-full shadow-2xl border-b-8 border-red-800 active:border-b-0 active:translate-y-2 transition transform hover:scale-105 marker-font tracking-widest">
            START GAME!
        </button>
    </div>

    <!-- Game UI Overlay -->
    <div id="gameUI" class="hidden absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-20">
        <!-- Top Bar -->
        <div class="flex justify-between items-start">
            <div class="bg-black/50 backdrop-blur-md p-3 rounded-lg border border-white/20">
                <div class="text-yellow-400 font-bold text-xl marker-font">TIME: <span id="timerDisplay" class="text-white">60</span></div>
                <div class="text-xs text-gray-300 mt-1" id="modeDisplay">Classic Tag</div>
            </div>
            
            <button onclick="endGame()" class="pointer-events-auto bg-red-600/80 hover:bg-red-500 text-white px-4 py-2 rounded font-bold border border-red-400 shadow-lg transition">
                QUIT
            </button>
        </div>

        <!-- Player Status (Bottom) -->
        <div class="flex justify-center gap-4 mb-2" id="playerStatusContainer">
            <!-- Generated via JS -->
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 z-30 bg-black/90 flex flex-col items-center justify-center p-4">
        <h2 class="text-6xl marker-font text-white mb-2 animate-bounce">GAME OVER</h2>
        <div id="winnerDisplay" class="text-3xl text-yellow-400 font-bold mb-8 text-center"></div>
        
        <div class="bg-gray-800 p-6 rounded-xl border border-gray-600 mb-8 w-full max-w-md">
            <h3 class="text-xl text-gray-300 mb-4 border-b border-gray-600 pb-2">Game Stats</h3>
            <div id="finalStats" class="space-y-2"></div>
        </div>

        <button onclick="resetToMenu()" class="px-8 py-3 bg-blue-600 hover:bg-blue-500 text-xl font-bold rounded-lg shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition">
            Back to Menu
        </button>
    </div>

    <canvas id="gameCanvas" class="hidden bg-gray-900 rounded-lg border-4 border-gray-700"></canvas>

    <script>
        // --- Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = {
            isPlaying: false,
            mode: 'classic',
            playerCount: 2,
            players: [],
            itIndex: 0,
            timeLeft: 60,
            lastTime: 0,
            particles: [],
            platforms: [],
            camera: { x: 0, y: 0 }
        };

        const CONTROLS = [
            { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', down: 'ArrowDown', jump: 'ArrowUp', name: 'Arrows' },
            { left: 'a', right: 'd', up: 'w', down: 's', jump: 'w', name: 'WASD' },
            { left: 'j', right: 'l', up: 'i', down: 'k', jump: 'i', name: 'IJKL' },
            { left: 'f', right: 'h', up: 't', down: 'g', jump: 't', name: 'TFGH' }
        ];

        const DEFAULT_COLORS = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B'];

        // --- Initialization ---

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupCustomization();
            setPlayerCount(2);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // --- Menu Logic ---

        function setPlayerCount(count) {
            gameState.playerCount = count;
            
            [2, 3, 4].forEach(n => {
                const btn = document.getElementById(`btn-p${n}`);
                if (n === count) {
                    btn.classList.remove('bg-gray-700', 'border-gray-900');
                    btn.classList.add('bg-blue-600', 'border-blue-800');
                } else {
                    btn.classList.add('bg-gray-700', 'border-gray-900');
                    btn.classList.remove('bg-blue-600', 'border-blue-800');
                }
            });

            setupCustomization();
        }

        function setGameMode(mode) {
            gameState.mode = mode;
            const btnClassic = document.getElementById('btn-mode-classic');
            const btnInfection = document.getElementById('btn-mode-infection');
            
            const activeClass = ['bg-green-600', 'border-green-800', 'hover:bg-green-500'];
            const inactiveClass = ['bg-gray-700', 'border-gray-900', 'hover:bg-gray-600'];

            if (mode === 'classic') {
                btnClassic.classList.remove(...inactiveClass);
                btnClassic.classList.add(...activeClass);
                btnInfection.classList.remove(...activeClass);
                btnInfection.classList.add(...inactiveClass);
            } else {
                btnInfection.classList.remove(...inactiveClass);
                btnInfection.classList.add(...activeClass);
                btnClassic.classList.remove(...activeClass);
                btnClassic.classList.add(...inactiveClass);
            }
        }

        function setupCustomization() {
            const grid = document.getElementById('customizationGrid');
            grid.innerHTML = '';

            for (let i = 0; i < gameState.playerCount; i++) {
                if (!gameState.players[i]) {
                    gameState.players[i] = {
                        color: DEFAULT_COLORS[i],
                        style: 'classic',
                        accessory: 'none',
                        isIt: false
                    };
                }

                const p = gameState.players[i];
                const controls = CONTROLS[i];

                const card = document.createElement('div');
                card.className = 'player-card bg-gray-700 p-4 rounded-lg border border-gray-600 flex flex-col items-center gap-3';
                
                card.innerHTML = `
                    <div class="flex items-center gap-2 w-full justify-between">
                        <span class="font-bold text-gray-300">P${i+1}</span>
                        <div class="flex gap-1 text-xs text-gray-400 font-mono">
                            <span class="bg-gray-800 px-1 rounded border border-gray-600">${controls.up}</span>
                            <span class="bg-gray-800 px-1 rounded border border-gray-600">${controls.left}</span>
                            <span class="bg-gray-800 px-1 rounded border border-gray-600">${controls.down}</span>
                            <span class="bg-gray-800 px-1 rounded border border-gray-600">${controls.right}</span>
                        </div>
                    </div>
                    
                    <div class="w-16 h-16 bg-gray-800 rounded-full flex items-center justify-center border-2 border-gray-500 relative overflow-hidden">
                        <canvas id="preview-${i}" width="64" height="64"></canvas>
                    </div>

                    <div class="flex gap-2">
                        ${DEFAULT_COLORS.map(c => `
                            <button onclick="setPlayerColor(${i}, '${c}')" 
                                class="w-6 h-6 rounded-full border-2 ${p.color === c ? 'border-white scale-110' : 'border-transparent'} transition hover:scale-110"
                                style="background-color: ${c}"></button>
                        `).join('')}
                    </div>

                    <div class="flex w-full bg-gray-800 rounded p-1">
                        <button onclick="setPlayerStyle(${i}, 'classic')" class="flex-1 text-xs py-1 rounded ${p.style === 'classic' ? 'bg-gray-600 text-white' : 'text-gray-400 hover:bg-gray-700'}">Classic</button>
                        <button onclick="setPlayerStyle(${i}, 'cool')" class="flex-1 text-xs py-1 rounded ${p.style === 'cool' ? 'bg-gray-600 text-white' : 'text-gray-400 hover:bg-gray-700'}">Cool</button>
                    </div>

                    <select onchange="setPlayerAccessory(${i}, this.value)" class="w-full bg-gray-800 text-xs text-gray-300 p-1 rounded border border-gray-600 outline-none">
                        <option value="none" ${p.accessory === 'none' ? 'selected' : ''}>No Hat</option>
                        <option value="cap" ${p.accessory === 'cap' ? 'selected' : ''}>Cap</option>
                        <option value="crown" ${p.accessory === 'crown' ? 'selected' : ''}>Crown</option>
                        <option value="headphones" ${p.accessory === 'headphones' ? 'selected' : ''}>Headphones</option>
                    </select>
                `;
                grid.appendChild(card);

                setTimeout(() => drawStickmanPreview(i, p), 0);
            }
        }

        function setPlayerColor(index, color) {
            gameState.players[index].color = color;
            setupCustomization();
        }

        function setPlayerStyle(index, style) {
            gameState.players[index].style = style;
            setupCustomization();
        }

        function setPlayerAccessory(index, acc) {
            gameState.players[index].accessory = acc;
            setupCustomization();
        }

        function drawStickmanPreview(index, p) {
            const c = document.getElementById(`preview-${index}`);
            if(!c) return;
            const x = c.getContext('2d');
            x.clearRect(0,0,64,64);
            x.translate(32, 40);
            renderStickmanBody(x, p, 0, 0, 0, false, 1);
        }

        // --- Game Logic ---

        class Player {
            constructor(id, config) {
                this.id = id;
                this.config = config;
                this.x = 200 + Math.random() * 400;
                this.y = 300;
                this.vx = 0;
                this.vy = 0;
                this.radius = 15;
                this.width = 20;
                this.height = 40;
                this.speed = 0.8;
                this.maxSpeed = 6;
                this.jumpPower = -14;
                this.gravity = 0.6;
                this.friction = 0.85;
                this.grounded = false;
                this.isIt = false;
                this.tagCooldown = 0; // Cooldown after being tagged
                this.tagImmunity = 0; // Immunity after tagging someone
                this.controls = CONTROLS[id];
                this.keys = {};
                this.facingRight = true;
                this.tags = 0; // Track tags made
                this.taggedCount = 0; // Track times tagged
            }

            update(platforms) {
                // Input handling
                let ax = 0;

                if (this.keys[this.controls.left]) {
                    ax -= this.speed;
                    this.facingRight = false;
                }
                if (this.keys[this.controls.right]) {
                    ax += this.speed;
                    this.facingRight = true;
                }

                // Jump
                if (this.keys[this.controls.jump] && this.grounded) {
                    this.vy = this.jumpPower;
                    this.grounded = false;
                    createDust(this.x, this.y + this.height/2, this.config.color);
                }

                // Apply physics
                this.vx += ax;
                this.vx *= this.friction;
                this.vy += this.gravity;

                // Cap horizontal speed
                if (this.vx > this.maxSpeed) this.vx = this.maxSpeed;
                if (this.vx < -this.maxSpeed) this.vx = -this.maxSpeed;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Platform collisions
                this.grounded = false;
                
                // Floor collision
                if (this.y + this.height/2 > canvas.height - 50) {
                    this.y = canvas.height - 50 - this.height/2;
                    this.vy = 0;
                    this.grounded = true;
                }

                // Platform collisions
                platforms.forEach(plat => {
                    // Check if landing on top
                    if (this.vy > 0 && 
                        this.y + this.height/2 <= plat.y + 10 &&
                        this.y + this.height/2 + this.vy >= plat.y &&
                        this.x + this.width/2 > plat.x &&
                        this.x - this.width/2 < plat.x + plat.width) {
                        
                        this.y = plat.y - this.height/2;
                        this.vy = 0;
                        this.grounded = true;
                    }
                    
                    // Hit head on bottom
                    if (this.vy < 0 &&
                        this.y - this.height/2 >= plat.y + plat.height - 10 &&
                        this.y - this.height/2 + this.vy <= plat.y + plat.height &&
                        this.x + this.width/2 > plat.x &&
                        this.x - this.width/2 < plat.x + plat.width) {
                        
                        this.y = plat.y + plat.height + this.height/2;
                        this.vy = 0;
                    }

                    // Side collisions
                    if (this.y + this.height/2 > plat.y + 5 &&
                        this.y - this.height/2 < plat.y + plat.height - 5) {
                        
                        // Left side
                        if (this.x + this.width/2 <= plat.x + 5 &&
                            this.x + this.width/2 + this.vx >= plat.x) {
                            this.x = plat.x - this.width/2;
                            this.vx = 0;
                        }
                        
                        // Right side
                        if (this.x - this.width/2 >= plat.x + plat.width - 5 &&
                            this.x - this.width/2 + this.vx <= plat.x + plat.width) {
                            this.x = plat.x + plat.width + this.width/2;
                            this.vx = 0;
                        }
                    }
                });

                // Wall boundaries
                if (this.x < this.width/2) {
                    this.x = this.width/2;
                    this.vx = 0;
                }
                if (this.x > 2000 - this.width/2) {
                    this.x = 2000 - this.width/2;
                    this.vx = 0;
                }

                // Cooldowns
                if (this.tagCooldown > 0) this.tagCooldown--;
                if (this.tagImmunity > 0) this.tagImmunity--;
            }

            draw(ctx, cameraX) {
                const isMoving = Math.abs(this.vx) > 0.1;
                
                ctx.save();
                ctx.translate(this.x - cameraX, this.y);
                
                // Flip based on facing direction
                if (!this.facingRight) ctx.scale(-1, 1);

                // Draw "IT" aura
                if (this.isIt) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 25 + Math.sin(Date.now() / 100) * 3, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.5 + Math.sin(Date.now() / 100) * 0.2})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('IT', -8, -35);
                }

                // Draw immunity shield if recently tagged
                if (this.tagCooldown > 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 255, 0, ${this.tagCooldown / 60})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                renderStickmanBody(ctx, this.config, this.vx, this.vy, 0, isMoving, 1.2);
                ctx.restore();
            }
        }

        function renderStickmanBody(ctx, config, vx, vy, angle, isMoving, scale) {
            ctx.scale(scale, scale);
            ctx.strokeStyle = config.color;
            ctx.fillStyle = config.color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const runCycle = isMoving ? Math.sin(Date.now() / 60) * 8 : 0;

            if (config.style === 'classic') {
                ctx.beginPath();
                ctx.arc(0, -15, 8, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, -7);
                ctx.lineTo(0, 10);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.lineTo(-8 + runCycle, 5);
                ctx.moveTo(0, -5);
                ctx.lineTo(8 - runCycle, 5);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, 10);
                ctx.lineTo(-6 - runCycle, 22);
                ctx.moveTo(0, 10);
                ctx.lineTo(6 + runCycle, 22);
                ctx.stroke();

            } else if (config.style === 'cool') {
                ctx.lineWidth = 5;
                
                ctx.beginPath();
                ctx.arc(0, -15, 9, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.strokeStyle = config.color;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(0, 12);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, -4);
                ctx.quadraticCurveTo(-10, 0, -12 + runCycle, 8);
                ctx.moveTo(0, -4);
                ctx.quadraticCurveTo(10, 0, 12 - runCycle, 8);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(-2, 12);
                ctx.lineTo(-6 - runCycle, 24);
                ctx.moveTo(2, 12);
                ctx.lineTo(6 + runCycle, 24);
                ctx.stroke();
            }

            if (config.accessory === 'cap') {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(-8, -18);
                ctx.lineTo(8, -18);
                ctx.lineTo(10, -12);
                ctx.lineTo(-10, -12);
                ctx.fill();
                ctx.fillRect(2, -18, 12, 2);
            } else if (config.accessory === 'crown') {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(-8, -20);
                ctx.lineTo(-4, -28);
                ctx.lineTo(0, -22);
                ctx.lineTo(4, -28);
                ctx.lineTo(8, -20);
                ctx.lineTo(8, -15);
                ctx.lineTo(-8, -15);
                ctx.fill();
            } else if (config.accessory === 'headphones') {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, -15, 11, Math.PI, 0);
                ctx.stroke();
                ctx.fillStyle = '#333';
                ctx.fillRect(-13, -18, 4, 8);
                ctx.fillRect(9, -18, 4, 8);
            }
        }

        // --- Game Loop Functions ---

        function generatePlatforms() {
            const platforms = [];
            const groundY = canvas.height - 50;
            
            // Ground platforms
            platforms.push({ x: 0, y: groundY, width: 600, height: 50 });
            platforms.push({ x: 700, y: groundY, width: 600, height: 50 });
            platforms.push({ x: 1400, y: groundY, width: 600, height: 50 });
            
            // Floating platforms - taggame.io style parkour
            platforms.push({ x: 200, y: groundY - 120, width: 120, height: 20 });
            platforms.push({ x: 400, y: groundY - 200, width: 100, height: 20 });
            platforms.push({ x: 600, y: groundY - 150, width: 100, height: 20 });
            platforms.push({ x: 850, y: groundY - 180, width: 120, height: 20 });
            platforms.push({ x: 1050, y: groundY - 250, width: 100, height: 20 });
            platforms.push({ x: 1250, y: groundY - 150, width: 100, height: 20 });
            platforms.push({ x: 1500, y: groundY - 200, width: 120, height: 20 });
            platforms.push({ x: 1700, y: groundY - 280, width: 100, height: 20 });
            platforms.push({ x: 300, y: groundY - 320, width: 150, height: 20 });
            platforms.push({ x: 550, y: groundY - 380, width: 100, height: 20 });
            platforms.push({ x: 800, y: groundY - 350, width: 120, height: 20 });
            platforms.push({ x: 1100, y: groundY - 400, width: 100, height: 20 });
            platforms.push({ x: 1350, y: groundY - 320, width: 120, height: 20 });
            platforms.push({ x: 1600, y: groundY - 380, width: 100, height: 20 });
            
            // High platforms
            platforms.push({ x: 450, y: groundY - 480, width: 200, height: 20 });
            platforms.push({ x: 900, y: groundY - 500, width: 200, height: 20 });
            platforms.push({ x: 1400, y: groundY - 480, width: 200, height: 20 });
            
            // Top platform
            platforms.push({ x: 750, y: groundY - 600, width: 500, height: 20 });

            return platforms;
        }

        function startGame() {
            gameState.players = [];
            for(let i=0; i<gameState.playerCount; i++) {
                const config = gameState.players[i] || { color: DEFAULT_COLORS[i], style: 'classic', accessory: 'none' };
                gameState.players[i] = new Player(i, config);
            }

            gameState.players.forEach(p => {
                p.tags = 0;
                p.taggedCount = 0;
            });

            gameState.itIndex = Math.floor(Math.random() * gameState.playerCount);
            gameState.players[gameState.itIndex].isIt = true;

            gameState.timeLeft = 90;
            gameState.isPlaying = true;
            gameState.particles = [];
            gameState.platforms = generatePlatforms();

            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
            canvas.classList.remove('hidden');
            document.getElementById('modeDisplay').innerText = gameState.mode === 'classic' ? 'Classic Tag' : 'Infection Mode';

            updateStatusUI();

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            gameState.lastTime = Date.now();
            requestAnimationFrame(gameLoop);
            
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            gameState.timerInterval = setInterval(() => {
                if (!gameState.isPlaying) return;
                gameState.timeLeft--;
                document.getElementById('timerDisplay').innerText = gameState.timeLeft;
                if (gameState.timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function handleKeyDown(e) {
            gameState.players.forEach(p => {
                if (Object.values(p.controls).includes(e.key)) {
                    p.keys[e.key] = true;
                }
            });
        }

        function handleKeyUp(e) {
            gameState.players.forEach(p => {
                if (Object.values(p.controls).includes(e.key)) {
                    p.keys[e.key] = false;
                }
            });
        }

        function gameLoop() {
            if (!gameState.isPlaying) return;

            // Camera follow the "IT" player
            const itPlayer = gameState.players[gameState.itIndex];
            const targetCamX = itPlayer.x - canvas.width / 2;
            gameState.camera.x += (targetCamX - gameState.camera.x) * 0.1;
            
            // Clamp camera
            if (gameState.camera.x < 0) gameState.camera.x = 0;
            if (gameState.camera.x > 2000 - canvas.width) gameState.camera.x = 2000 - canvas.width;

            // Clear
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw background grid (parallax)
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gridOffset = -(gameState.camera.x * 0.5) % 50;
            for(let x=gridOffset; x<canvas.width; x+=50) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for(let y=0; y<canvas.height; y+=50) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // Draw platforms
            ctx.fillStyle = '#4a5568';
            ctx.strokeStyle = '#718096';
            ctx.lineWidth = 2;
            
            gameState.platforms.forEach(plat => {
                if (plat.x - gameState.camera.x > canvas.width || plat.x + plat.width - gameState.camera.x < 0) return;
                
                ctx.fillRect(plat.x - gameState.camera.x, plat.y, plat.width, plat.height);
                ctx.strokeRect(plat.x - gameState.camera.x, plat.y, plat.width, plat.height);
                
                // Platform detail
                ctx.fillStyle = '#2d3748';
                ctx.fillRect(plat.x - gameState.camera.x + 5, plat.y + 5, plat.width - 10, plat.height - 10);
                ctx.fillStyle = '#4a5568';
            });

            // Update & Draw Players
            gameState.players.forEach(p => {
                p.update(gameState.platforms);
                p.draw(ctx, gameState.camera.x);
            });

            checkTagging();
            updateParticles();

            requestAnimationFrame(gameLoop);
        }

        function checkTagging() {
            const itPlayer = gameState.players[gameState.itIndex];
            
            // IT player must not be in immunity
            if (itPlayer.tagImmunity > 0) return;

            for (let i = 0; i < gameState.players.length; i++) {
                if (i === gameState.itIndex) continue;

                const target = gameState.players[i];
                
                // Target must not be in cooldown
                if (target.tagCooldown > 0) continue;

                const dx = itPlayer.x - target.x;
                const dy = itPlayer.y - target.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < itPlayer.radius + target.radius + 10) {
                    performTag(i);
                    break;
                }
            }
        }

        function performTag(newItIndex) {
            const oldIt = gameState.players[gameState.itIndex];
            const newIt = gameState.players[newItIndex];

            oldIt.isIt = false;
            oldIt.tagImmunity = 60; // 1 second immunity after tagging
            oldIt.tags++;
            
            newIt.isIt = true;
            newIt.tagCooldown = 120; // 2 seconds immunity after being tagged (can't be tagged back instantly)
            newIt.taggedCount++;
            
            gameState.itIndex = newItIndex;

            if (gameState.mode === 'infection') {
                // In infection, tagged players stay tagged
                oldIt.isIt = true;
            }

            createExplosion(newIt.x, newIt.y, '#ff0000');
            updateStatusUI();
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<30; i++) {
                gameState.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function createDust(x, y, color) {
            for(let i=0; i<8; i++) {
                gameState.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 3,
                    life: 0.5,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        function updateParticles() {
            for(let i=gameState.particles.length-1; i>=0; i--) {
                let p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // gravity
                p.life -= 0.03;
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x - gameState.camera.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                if(p.life <= 0) gameState.particles.splice(i, 1);
            }
        }

        function updateStatusUI() {
            const container = document.getElementById('playerStatusContainer');
            container.innerHTML = '';

            gameState.players.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = `flex flex-col items-center bg-black/60 p-2 rounded border ${p.isIt ? 'border-red-500 shadow-[0_0_10px_rgba(255,0,0,0.5)]' : 'border-gray-600'}`;
                
                const avatar = document.createElement('canvas');
                avatar.width = 40;
                avatar.height = 40;
                const ax = avatar.getContext('2d');
                ax.translate(20, 35);
                renderStickmanBody(ax, p.config, 0, 0, 0, false, 0.8);

                div.innerHTML = `
                    <div class="mb-1">${avatar.outerHTML}</div>
                    <div class="text-xs font-bold text-white">P${i+1}</div>
                    ${p.isIt ? '<div class="text-[10px] text-red-500 font-bold animate-pulse">IT</div>' : '<div class="text-[10px] text-gray-500">SAFE</div>'}
                `;
                container.appendChild(div);
            });
        }

        function endGame() {
            gameState.isPlaying = false;
            clearInterval(gameState.timerInterval);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);

            let winnerText = '';
            if (gameState.mode === 'classic') {
                // Most tags wins
                let maxTags = -1;
                let winner = null;
                gameState.players.forEach(p => {
                    if (p.tags > maxTags) {
                        maxTags = p.tags;
                        winner = p;
                    }
                });
                winnerText = winner ? `<span style="color:${winner.config.color}">Player ${winner.id + 1}</span> Wins!<br><span class="text-lg text-gray-400">${maxTags} tags made</span>` : 'Tie!';
            } else {
                // Infection - last survivor wins (or most tags if time runs out)
                const survivors = gameState.players.filter(p => !p.isIt);
                if (survivors.length === 1) {
                    winnerText = `<span style="color:${survivors[0].config.color}">Player ${survivors[0].id + 1}</span> Survived!`;
                } else {
                    winnerText = 'Infection Complete!';
                }
            }

            document.getElementById('winnerDisplay').innerHTML = winnerText;

            const statsDiv = document.getElementById('finalStats');
            statsDiv.innerHTML = gameState.players.map(p => `
                <div class="flex justify-between items-center p-2 bg-gray-700 rounded">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background-color:${p.config.color}"></div>
                        <span>Player ${p.id + 1}</span>
                    </div>
                    <div class="text-right text-sm">
                        <div class="text-green-400">${p.tags} tags</div>
                        <div class="text-red-400 text-xs">${p.taggedCount} tagged</div>
                    </div>
                </div>
            `).join('');

            document.getElementById('gameUI').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function resetToMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
            canvas.classList.add('hidden');
            setupCustomization();
        }

        init();

    </script>
</body>
</html>
